---
title: 4_Connectomics
output: html_notebook
---

## Setup
Basic installation/update:
```{r, eval=FALSE}
natmanager::install('natverse')
natmanager::install(pkgs = 'jefferis/vfbconnectr')
# update Python package
vfbconnectr::vc_install()
```


```{r, message=FALSE}
# load packages
library(vfbconnectr)
library(natverse)
library(dplyr)

# if Running on Rstudio server (==cloud) use plotly as visualisation default
#if(isTRUE(Sys.getenv('RSTUDIO_PROGRAM_MODE')=="server"))
options(nat.plotengine = 'plotly')
```

Set up connections to VFB APIs and VFB CATMAID server.

```{r}
vc = VfbConnect()
# Connect to the VFB CATMAID server hosting the FAFB data
catmaid::vfbcatmaid('fafb')
```


### VFB provides a simple way in to exploring connectomics data

Get connections between defined upstream and downstream neuron types:

```{r}
vc$get_connected_neurons_by_type(upstream_type='GABAergic neuron', downstream_type='adult descending neuron', weight=10)
```

Get neurons downstream of a neuron

```{r}
vc$get_neurons_downstream_of('DA3_adPN_R - 1703683361', weight = 20)
```

Get neurons downstream of a neuron, filtered by a classification.

```{r}
vc$get_neurons_downstream_of('DA3_adPN_R - 1703683361', classification="'Kenyon cell'", weight = 20)
```

### More sophisticated connectomics queries require direct queries of connectomics DB APIs

#### CATMAID connectivity queries

Broadly speaking, CATMAID lets you fetch connectivity data as either lists of up- and downstream partners or as whole adjacency matrices.

These examples use the VFB FAFB server.

```{r}
# Using VFB to get neurons by type
DA1_tab = vc$get_instances("'adult antennal lobe projection neuron DA1'", summary=TRUE) %>%
  vc_df()
DA1_tab
```

```{r}
# Map neurons to CATMAID Skeleton IDs (skids)
da1_id_list = vc$neo_query_wrapper$vfb_id_2_xrefs(DA1_tab[,'id'], db='catmaid_fafb', reverse_return=TRUE)
# the names of each element in the list are the actual ids
da1_skids = names(da1_id_list)
da1_skids
```

Generate a connectivity table for neurons downstream of DA1 neurons

```{r}
da1 = read.neurons.catmaid(da1_skids)
da1_ds = catmaid_get_connector_table(da1_skids_int, direction = )

# Result is a pandas DataFrame
da1_ds.head()
```

```{r}
# Get an adjacency matrix between all Bates, Schlegel et al. neurons
bates = pymaid.find_neurons(annotations='Paper: Bates and Schlegel et al 2020')
adj = pymaid.adjacency_matrix(bates)
adj.head()
```

```{r}
import seaborn as sns 

ax = sns.clustermap(adj, vmax=10, cmap='Greys')
```



```{r}
# Axo-axonic connections between two different types of DA1 PNs
cn = pymaid.get_connectors_between(2863104, 1811442)
cn.head()
```

```{r}
import numpy as np 

points = np.vstack(cn.connector_loc)

navis.plot3d([da1.idx[[1811442, 57353
]],  # plot the two neurons
              points],  # plot the points of synaptic contacts as scatter 
              scatter_kws=dict(name="synaptic contacts")
              )
```

#### neuprint connectivity queries

To programmatically interface with neuprint, we will use neuprint-python (link). It requires an API token which you can get via the website and is bound to the Google account that you use to log into neuprint. For this workshop we provide such a token as environment variable but you will need to start using your own token after the workshop is over.

These examples use the hemibrain v1.1 dataset.

### neuprint-python
First we have to initialize the connection.

```{r}
import neuprint as neu
client = neu.Client('https://neuprint.janelia.org', dataset='hemibrain:v1.1')
```

Most functions in `neuprint-python` accept `neu.NeuronCriteria` which is effectively a filter for body IDs, types, etc:

```{r}
help(neu.NeuronCriteria)
```

### Fetching neurons

Let's say we want to find all antennnal lobe projection neurons (PNs). Their type nomenclature adheres to `{glomerulus}_{lineage}PN` (e.g. `DA1_lPN`)for uniglomerular PNs and a `M_{lineage}PN{tract}{type}` (e.g. `M_vPNml50` = "**m**ultiglomerular **v**entral lineage **PN** **m**edio**l**ateral tract type **50**) for multiglomerular PNs. 

To get them all, we need to use regex patterns (see this [cheatsheet](https://cheatography.com/davechild/cheat-sheets/regular-expressions/)):

```{r}
# Define the filter criteria
nc = neu.NeuronCriteria(type='.*?_.*?PN.*?', regex=TRUE)

# Get general info for these neurons 
pns, roi_info = neu.fetch_neurons(nc)

print(f'{pns.shape[0]} PNs found.')

pns.head()
```

```{r}
# Check that the regex did not have any accidental by-catch
pns['type'].unique()
```

Find neuron types with VFB instead:

```{r}
ALPNs = vc$get_instances("'adult antennal lobe projection neuron'", summary=TRUE)
pd.DataFrame.from_records(ALPNs)
```

### Fetching synaptic partners

Looks good! Next: What's downstream of those PNs?

```{r}
ds = neu.fetch_simple_connections(upstream_criteria=neu.NeuronCriteria(bodyId=pns.bodyId.values))
ds.head()
```

Each row is now a connections from a single up- to a single downstream neuron. The "weight" is the number of synapses between the pre- and the postsynaptic neuron. Let's simplify by grouping by type:

```{r}
by_type = ds.groupby(['type_pre', 'type_post'], as_index=False).weight.sum()
by_type.sort_values('weight', ascending=False, inplace=TRUE)
by_type.reset_index(drop=TRUE, inplace=TRUE)
by_type.head()
```

The strongest connections are between PNs and Kenyon Cells (KCs). That's little surprising since there are thousands of KCs. For the sake of the argument let's say we want to know _where_ these connections occur:

```{r}
adj, roi_info2 = neu.fetch_adjacencies(sources=neu.NeuronCriteria(bodyId=pns.bodyId.values),
                                       targets=neu.NeuronCriteria(type='KC.*?', regex=TRUE))
roi_info2.head()  
```

```{r}
# Group by region of interest (ROI)
by_roi = roi_info2.groupby('roi').weight.sum()
by_roi.head()
```

```{r}
ax = by_roi.plot.bar()
ax.set_xlabel('')
ax.set_ylabel('PN to KC synapses')
```

#### Querying paths
Let's say we want to find out how to go from a PN (second order olfactory neurons) all the way to a descending neuron (presumably leading to motor neurons in the VNC).

```{r}
# First fetch the DNs
dns, _ = neu.fetch_neurons(neu.NeuronCriteria(type='(.*DN[^1]{0,}.*|Giant Fiber)', regex=TRUE))
dns.head()
```

Neuprint lets you query paths from a single source to a single target. For multi-source or -target queries, your best bet is to download the entire graph and run the queries locally using networkx or igraph.

```{r}
# Find all paths from A PN to A DNs 
paths = neu.fetch_shortest_paths(upstream_bodyId=pns.bodyId.values[0],
                                 downstream_bodyId=dns.bodyId.values[0],
                                 min_weight=10)
paths        
```

So it looks like there are three separate 7-hop paths to go from `M_vPNml53` to `DN1a`. Let's visualize the neurons involved!

### Fetching meshes & skeletons
You can fetch skeletons as SWCs directly via `neuprint-python`. For visualization however it's easiest to load neuron morphologies via `navis`. For that `navis` wraps `neuprint-python` and adds some convenience functions (see also the [tutorial](https://navis.readthedocs.io/en/latest/source/tutorials/neuprint.html)):

```{r}
library('neuprintr')
neuprint_login()
```


```{r}
neuprint_datasets()
```

```{r}
nl = neuprint_read_neurons(bodyids = c(818983130, 1796818119))
```

```{r}
al_r.mesh = neuprint_ROI_mesh(roi = "AL(R)")
lh_r.mesh = neuprint_ROI_mesh(roi = "LH(R)")
ca_r.mesh = neuprint_ROI_mesh(roi = "CA(R)")
```

```{r}
options(nat.plotengine = 'plotly')
nclear3d()
plot3d(nl,plotengine = 'plotly')
wire3d(al_r.mesh, col = 'red', alpha = 0.1)
wire3d(lh_r.mesh,col = 'magenta', alpha = 0.1)
wire3d(ca_r.mesh,col = 'blue', alpha = 0.1)
```




```{python}
# Import the wrapped neuprint-python 
# -> this exposes ALL base functions plus a couple navis-specific extras
import navis
import navis.interfaces.neuprint as neu 

client = neu.Client('https://neuprint.janelia.org', dataset='hemibrain:v1.1')

# Fetch neurons in the first path
nl = neu.fetch_skeletons(paths.loc[(paths.path == 0), 'bodyId'])
nl
```

```{python}
# Let's also get some ROI meshes
al = neu.fetch_roi('AL(R)')
lh = neu.fetch_roi('LH(R)')
ca = neu.fetch_roi('CA(R)')
```

```{python}
# Plot
navis.plot3d([nl, lh, al, ca], width=1100)
```
